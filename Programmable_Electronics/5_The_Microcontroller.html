<!DOCTYPE html>
<html>
<head>
 <meta charset="utf-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1" />
 <link rel="stylesheet" href="polycop.css" />
 <title>The Microcontroller</title>
</head>
<body>
<div class="large">
<center>
<h1>5. The Microcontroller</h1>
</center>
<p>A microcontroller is a computer on a chip, designed to work with a minimal number of external components - in fact some can work with no external component at all.</p>
<p>Microcontrollers are manufactured to be embedded in products which are no perceived as computers by the end-user.<br>
Due to their low cost and the flexibility of software solutions, they make an increasing fraction of the electronic hardware in general.</p> 

<p>Like every computer, a microcontroller is a digital system, made of logic gates and memories, themselves made of transistors.<br>
While desktop computers may also contain electro-magnetic devices like hard discs and electro-optical devices like CD/DVD units, microcontrollers are just highly complex fabrics of transistors, containing millions of them.</p>

<p>Having no operating system, a microcontroller executes constantly the only program its memory contains, however it is able to execute many tasks concurrently (in parallel).</p>

<h2>5.1 Binary words and memory addresses</h2>

<h3>5.1.1 Words</h3>
<p>Internally, computer work on binary data or bits.<br>
Since working on one bit at a time would be inefficient, data are organized in binary words, which are fixed size collections of bits. For interoperability reasons, the word size is frequently a multiple of 8 bits.</p>
<p>An 8-bit binary word is an octet or byte.</p>

<h3>5.1.2 Numbers</h3>
<p>A binary word may represent a number, for this purpose a weight is assigned to each bit:</p>
<ul><li>the bit with the smallest weight (which is 1), is the LSB (Least Significant Bit)</li>
<li>the bit with the greatest weight is the MSB (Most Significant Bit)</li>
</ul>
<p>Signed integer number representation in computers normally uses the <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a> scheme, while fractionnal numbers said <a href="https://en.wikipedia.org/wiki/IEEE_754">floating point numbers</a> are represented by words divided in three fields: sign bit, exponent and mantissa.</p>
<p>Reading binary data is uneasy for humans, so developers prefer to use base-16 or <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a> numbers to represent binary words comfortably in documentation and programs.</p>

<h3>5.1.3 Text</h3>

<p>A binary word may be used to represent a text character. It appears that 8 bits are sufficient for representing the letters used by latin alphabets,
so the starting point was a code known as <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>, representing all the characters of an american typewriter (for which 7 bits would have been sufficient).<br>
Several solutions were proposed to extend this code to non-latin languages, the most successful being UTF-8, which uses a variable-length code, compatible with ASCII.</p>
<p>A piece of text is represented as a sequence of bytes, called a string. It is a common practice to use the zero byte (null character) to mark the end of the string.</p>

<div class="nob">
<h3>5.1.4 Addresses</h3>
<p>In computer memory, data words are stored in 1D-arrays, which can be considered as tables where each line contains a binary word.<br>
The lines are numbered in sequence, and their numbers are called the addresses, which are themselves handled in binary form.<p>
<p>Many computers can read or write words which are larger than 8 bits, but to preserve the capability or writing or reading single bytes, the adresses are always byte addresses.</p>
</div>

<h3>5.1.5 Instructions</h3>
<p>Programs in machine code are sequences of instructions coded and stored as compact binary words. The code is architecture-specific and not readable by humans.<br>When the instruction word size is fixed, the archicture is called RISC (Reduced Instruction Set Computer), otherwise it is called CISC (Complex Instruction Set Computer).</p>
<ul><li>Programs written in languages like assembly, C, C++, Java are translated into binary code in advance, by a program called compiler (or assembler).</li>
<li>Programs written in scripting languages like bash, javascript, python, php are translated during execution, by a program called interpreter.</li>
</ul>

<h3>5.1.6 Bit Level Operations</h3>
<p>Bit level operations are implemented on every computer, but they are of a higher importance for the microcontroller developer, since they are involved in nearly every interaction with peripherals.</p>
<h4>Bit shift</h4>
<img src="bit_shifts.png">
<p>Bit shift operations shift bits to the left (which is towards higher weights) or to the right (which is towards lower weights), and there are two modes of right-shifting</p> 
<p>When bits are shifted left by one position, the MSB (Most Significant Bit, b<sub>7</sub> in the example) is dropped, while a zero is injected in the LSB position.<br>
If the word represents a number (not too great), it is multiplied by 2</p>
<p>When bits are shifted right by one position in "unsigned" or "logic" mode, the LSB (Least Significant Bit, b<sub>0</sub>) is dropped, while a zero is injected in the MSB position.<br>
If the word represents an unsigned number, it is divided by 2.</p>
<p>When bits are shifted right by one position in "signed" or "arithmetic" mode, the MSB is duplicated, with the intention of preserving the sign of a signed number coded in two's complement.<br>
If the word represents a signed number, it is divided by 2.</p>

<div class="nob">
<p>In C and C++, these operations are supported by means of the "&lt;&lt;" and "&gt;&gt;" operators. The mode (unsigned or signed) is determined according to the type of the first operand.</p>
</div>

<h4>Bit set and reset</h4>
<img src="bit_force.png">
<p>In the first example, a bit is "forced" to 1 or "set", without affecting the other bits, by means of a bitwise logic OR operation with a constant containing zeros except in one place.</p>
<p>In the second example, a bit is "forced" to 0 or "reset", without affecting the other bits, by means of a bitwise logic AND operation with a constant containing ones except in one place. Such a constant is called a "mask".</p>
<p>In the third example, a bit is inverted or complemented, without affecting the other bits, by means of a bitwise logic XOR (eXclusive Or) operation with a constant containing zeroes except in one place.</p>
<p>In C and C++, these operations are supported by means of the bitwise logic operators "|", "&amp;" and "^" operators. In addition, the "~" operator performs the NOT function, complementing all the bits.<br>
Note: these should not be confused with the boolean operators "||", "&amp;&amp;" and "!" which handle words considered each one as a single boolean value.</p>
<p>Examples in C :</p>
<pre>A |=  ( 1 &lt;&lt; 5 );  // bit 5 (weight 32) in A is forced to 1
B &amp;= ~( 1 &lt;&lt; N );  // bit N (weight 2<sup>N</sup>) in B is forced to zero</pre>


<h2>5.2 Microcontroller architecture</h2>

<img src="microcontroller_diagram.png">

<div class="nob">
<p>The main modules inside a microcontroller are :</p>
<ul><li>the CPU (Central Processing Unit),<br>which processes binary words that it reads and writes from memory and peripheral through the bus</li>
<li>the non-volatile memory, sometimes called ROM or flash memory or program memory,<br>which contains programs and constant data</li>
<li>the volatile memory, generally called RAM or data memory, which contains the temporary data</li>
<li>the peripherals, which permit communication with the outer world in various forms</li>
<li>the bus lines which support the communication between these modules</li>
</ul>
</div>

<p>The parameters that characterize a microcontroller type are:</p>
<ul><li>the CPU family, which determines the instructions encoding and the performance level</li>
<li>the word size, either 8 bits, 16 bits, 32 bits or 64 bits,<br>
this is the typical data word that the CPU can process at once, but the definition of this parameter is not uniform, for example an 8-bit microcontrollers may use 16-bit addresses and 12-bit instructions, but performs calculations on 8-bit data only</li>
<li>the RAM size</li>
<li>the program memory (flash) size</li>
<li>the maximum clock frequency</li>
<li>the capability of the peripheral modules</li>
</ul>

<h3>5.2.1 CPU features</h3>
<p>The CPU contains a small number of registers which can store temporary data words which are accessed directly by instructions, without the need of an address.<br>
Some of these have a special role, like keeping the next instruction address or the return address of a subroutine.</p>
<p>The CPU contains an ALU (Arithmetic and Logic Unit), which in the simplest form performs addition, subtraction and boolean and shift operations.<br>
In this case, more complex operations like multiplication and division are performed by software, by combining simpler operations.<br>
More advanced CPUs can perform multiplication and division in a single instruction, and high-end CPUs have the hardware floating point capability.</p> 
<h3>5.2.2 RAM memory</h3>
<p>Microcontrollers use static RAM (SRAM), which is fast and consumes little power, but is limited to smaller capacities than the dynamic RAM (DRAM) used in desktop computers.</p>
<p>RAM is volatile, which means that the data it contains are lost each time the power is switched off.</p>
<p>The fact of being volatile is a disvantage, but this memory is much faster than non-volatile memories in particular when writing.</p> 
<p>In architectures where the data memory and the program memory are entirely separated ("Harward architectures"), the RAM is simply called "data memory".</p>

<div class="nob">
<h3>5.2.3 FLASH memory</h3>
<p>Microcontrollers need some non-volatile memory to have some program ready to execute immediately after power-up.<br>
Non volatile memory can be :</p>
<ul><li>pure ROM (Read Only Memory) also named OTP (One Time Programmable) memory</li>
<li>EEPROM (Electrically Erasable and Programmable ROM) which can be written but is treated as ROM by the application programs</li>
<li>FLASH memory, which is just a high density EEPROM where erasing is done one large blocks instead of single words</li>
</ul>
<p>In modern microcontrollers, programs are generally stored in flash memory. The CPU can read this memory, but not write into it.<br>
Writing requires either an external hardware or a dedicated peripheral, and takes much more time than a regular memory access.</p>
<p>A small amount of OTP-ROM is sometimes present to store the program which is used to write programs into the flash memory under control of the development computer. Such a program is called the bootloader.</p> 
</div>

<h3>5.2.4 Peripherals</h3>
<p>The CPU communicates with the peripheral by means of specialized registers which have a dedicated address space besides the main memories.</p>
<p>There are many types of specialized peripherals, here are the most common.</p>

<h4>GPIO: General Purpose Input-Output</h4>
<p>Each pin involved in GPIO can be programmed as a logic input or a logic output, and then handles one bit at a time under program control.</p>
<p>Logic 1 or "true" is represented by a high voltage, close to the power supply voltage (most often 3.3 Volts), while logic 0 or "false" is represented by a voltage close to zero (ground).</p>
<p>GPIO pins can source or sink a limited current, 4 mA to 20 mA depending on the model</p>

<h4>Serial communication principle</h4>
<p>Serial communication involves the transmission of all the bits of each word in sequence, one after the other. The speed is reduced compared with parallel busses, but the cost of wiring is lower.</p>
<p>Some serial communication schemes transmit the MSB (most significant bit) first, some others transmit the LSB first.</p>

<table class="bw">
<tr><td></td><td></td><td>data<br>wires</td><td>clock<br>wires</td><td>select<br>wires</td><td>total wires<br>incl. gnd</td><td>typ. speed</td><td>protocol</td><td>range</td></tr>
<tr><td>UART</td><td>Universal Asynchronous<br> Receiver-Transmitter</td><td>2</td><td>0</td><td>0</td><td>3</td><td>115200 Bauds</td><td>peer-to-peer</td><td>PCBs</td></tr>
<tr><td>I2C<br>TWI</td><td>Inter-Integrated Circuit<br>Two Wire Interface</td><td>1</td><td>1</td><td>0</td><td>3</td><td>400 kbits/s</td><td>master-slave</td><td>PCBs</td></tr>
<tr><td>SPI</td><td>Serial Peripheral Interface</td><td>2</td><td>1</td><td>1+</td><td>5</td><td>25 Mbits/s</td><td>master-slave</td><td>PCBs</td></tr>
<tr><td>USB</td><td>Universal Serial Bus</td><td>2</td><td>0</td><td>0</td><td>4</td><td>480 Mbits/s</td><td>master-slave</td><td>Desk</td></tr>
<tr><td>Ethernet</td><td>LAN (Local Area Network)</td><td>4</td><td>0</td><td>0</td><td>4</td><td>100 Mbits/s</td><td>peer-to-peer</td><td>Building</td></tr>
</table>

<div class="nob">
<h4>Serial asynchronous communication : UART</h4> 
<p>UART transmits blocks of one byte, framed by a "start" bit (always zero) and a "stop bit" (always 1).</p>
<img src="uart_signal.png">
<p>The start bit leading edge causes the synchronisation of the receiver clock, which is used to sample the data bits. The synchronization is reset at the start of each byte</p>
<p>The receiver clock frequency must be configured to match the transmitter clock frequency with a sufficient accuracy (~2%).<br>
This frequency is historically called the "Baud rate". The usual Baud rates values are such as 300 * 2<sup>N</sup>.</p>
<p>No master is defined at the hardware level, this is left to the application software.</p>
<p>For increasing the range to building area, the UART signals are amplified to higher voltages (RS232) or differential signals (RS485).
RS232 is obsolete but RS485 is still used for industrial equipments</p>  
</div>

<h4>Serial synchronous communication : I2C</h4>
<p>I2C is sometimes named TWI for historical copyright reasons.</p>
<img src="I2C_transfer_simplified.png">
<p>The master provides the clock signal on SCL, and the data line SDA is bidirectional.<br>The master creates special patterns S (Start) and P (stop) to mark the block limits.</p>
<p>The direction of transfer on the data line may be changed during a transaction, which involves a complex protocol.</p>
<p>The bus supports several slaves, thanks to an address field inserted by the master at the beginning of a transaction.</p>


<h4>Serial synchronous communication : SPI</h4>
<p>SPI is a very simple but loosely defined serial communication scheme</p>
<img src="SPI_single_slave.png">
<p>It uses 2 unidirectional data lines MOSI (Master Out Slave In) and MISO (Master In Slave Out).<br>
There is one active-low SS (Slave Select) signal for each slave, which the master uses to select a slave before driving the clock line SCLK.</p>
<div class="boite">
<img src="SPI_modes.png" class="rightim">
<p>There are 4 modes described in the initial specification, but what really matters is the direction of the clock edge which is used to sample data at the receiving end of each data line.</p>
<ul><li>Modes 0 and 3: data sampled at the rising clock edge</li>
<li>Modes 1 and 2: data sampled at the falling clock edge</li></div>


<h4>TIMER: Time keeping and PWM signal generation</h4>
<p>A timer is a digital binary counter driven by a periodic signal (the CPU clock or a signal derived from it by frequency division).<br>
It provides a high resolution time measurement (microseconds) and can generate periodic binary signals of arbitrary period and arbitrary pulse width (period and pulse width being multiples of the clock period).</p>
<img src="pwm_from_sinewave.png">
<p>The pulse width may be modulated in real time to produce a PWM signal (Pulse Width Modulation).<br>
The average value of the PWM signal is proportional to the function used to modulate the pulse width.<br>
This makes a convenient way to generate a slowly varying analog signal using a single digital pin, and to control a power device with reduced losses compared to a continous control.</p>

<div class="nob">
<h4>ADC and DAC</h4>
<p>The ADC (Analog to Digital Converter) produces a binary number proportional to the voltage received on a pin.</p>
<p>The conversion is not continuous and must be triggered periodically by software, or directly by a timer.</p>
<p>This periodic conversion has the same limitations as any sampled signal processing, notably the input signal frequency should no exceed half the sampling frequency, otherwise the acquired signal is corrupted by aliasing (See chapter 4.4 The aliasing issue)</p>

<p>The DAC (Digital to Analog Converter) produces the inverse service. Notice that a timer in PWM mode also makes an economical DAC solution, but its output should be filtered to obtain a clean analog signal.</p>
</div>

<div class="nob">
<h4>RTC : Real Time Clock</h4>
<p>The RTC keeps the time and date even when the main power supply is off, having a separate power supply.<br>Like watches, the RTC has a very low power need, being able to run for years on a small battery.</p>
<p>The RTC modules frequently contain a small amount of memory called the backup RAM, which keep application data when the microcontroller is off.</p>
</div>
   
<h3>5.2.5 Interrupts</h3>
<p>The CPU may accept a hardware interrupt signal from some peripherals. When this happens, the CPU completes the current instruction and then leaves the current instruction sequence and jumps to a specific interrupt service routine subroutine or interrupt handler, in order to perform some action required by the peripheral which emitted the interrupt request.</p>
<p>When the end of the interrupt routine is reached, the CPU returns to the instruction sequence where it was interrupted. To ensure that the interrupted task is not disturbed by this process, a context saving sequence is strictly applied before entering the interrupt routine, and a matching context restoring sequence is applied upon return, by hardware and software combined.</p>
<h4>Interrupt vectoring</h4>
<p>An interrupt controller may be used to manage several sources of interrupt requests, and to associate a dedicated interrupt routine for each of these sources. This is called interrupt vectoring.</p>
<h4>Interrupt priority</h4>
<p>The interrupt controller manages simultaneous interrupt requests by following some priority rules. On the simplest microcontrollers, a fixed priority is assigned to each peripheral. On more advanced ones, the priority level of each source can be set by program.</p>
<h4>Interrupt nesting</h4>
<p>On the simplest microcontrollers, interrupts are disabled upon entry into an interrupt routine, but the code inside this routine may re-enable interrupts to permit the interruption of itself by another source, considered as deserving a quicker handling. In any case interrupts are automatically enabled after return from the interrupt routine.</p>
<p>On more advanced architecture, the interrupt controller may permit automatically the interruption of an interrupt routine by another interrupt of higher priority, this is called interrupt nesting.</p>
<h4>Deadlock risk</h4>
<p>If inside an interrupt routine, a function is called to perform some communication action which depends on a lower priority interrupt service, this action will never be completed and the system will be blocked. To avoid this, the developer should be aware of all possible sources of interrupt requests.</p>

<div class="nob">
<h4>Multitasking</h4>
<p>Interrupts are essentiel to the implementation of multitasking, in computers of any size as well as in microcontrollers. A periodic interrupt requested by a timer is theoretically sufficient to make a multitask system, but a more efficient handling of I/O streams is permitted by specific interrupts</p>
<ul><li>In personal computers, interrupts are managed by the operating system in a manner which is transparent for the application programs</li>
<li>On microcontrollers, managing interrupts is the developer's business</li>
</ul>
</div>

<h2>5.3 Working with the Arduino</h2>
<p><a href="https://www.arduino.cc/">Arduino</a> is the name of an Italian private company which made a successful attempt to enable non-professionals to learn electronics through embedded computing, and produce some home-made microcontroller based applications.</p>
<p>In this context, Arduino produced a minimal development platform, based on a moderate cost microcontroller board and a user-friendly free development software.<br>
When people talk about "The Arduino" they refer to the board, or to the microcontroller itself.</p>
<p>While some choices made by Arduino are highly questionable, the benefit of this project is a worldwide acceleration of the DIY (Do-It-Yourself) microcontroller development activity. Notably many competing manufacturers put higher performance, lower cost boards on the market, while the open source community produced alternate software solutions.</p>

<h3>5.3.1 The Arduino Uno hardware</h3>
<p>The Uno is the first Arduino board and the most famous. While its technology was nearly outdated when it was introduced, it is still produced.</p>
<img class="wide" src="Arduino_Uno_pinout.png" width="100%">

<div class="nob">
<p>The board is equipped with two microcontrollers :</p>
<ul><li>the target microcontroller, which executes the user's programs and exposes 22 I/O pins for external wiring</li>
<li>the USB gateway microcontroller, which acts like a bridge between the target microcontroller's UART and the host computer's USB port</li>
</ul>
<p>On delivery, the target microcontroller flash memory contains already a small bootloader program, which is ready to receive program data via the UART and write them into the remaining space in the flash memory. The gateway microcontroller contains the USB-UART bridge software.</p>

<p>Why 2 microcontrollers? The USB communication protocol is extremely complex and having the USB port on the target microcontroller would not have left sufficient resources for the user programs. In the other hand, the UART-based bootloader is lightweight.</p>
</div>

<p>The target microcontroller is an ATmega328P made by ATMEL (now belonging to Microchip), with the following characteristics:</p>
<ul><li>8-bit AVR RISC CPU</li>
<li>5 Volts power supply and I/O</li>
<li>16MHz clock</li>
<li>32 kbytes of flash memory</li>
<li>1 kbyte of EEPROM memory</li>
<li>2 kbytes of RAM memory</li>
<li>Harvard architecture : Flash and RAM accessed in parallel</li>
<li>Vectored interrupts (26 vectors) with fixed priority</li>
<li>Three timers with 2 PWM channels each</li>
<li>One SPI port, with an 8-bit shift register</li>
<li>One UART</li>
<li>One I2S "2-wire Serial Interface"</li>
<li>One ADC, 10 bits resolution, 15 ksamp/s, 6 multiplexed inputs</li>
</ul>

<p>The Uno board exposes a proprietary connector layout for which many accessory boards, called "shields", were developed.</p>
<p>The Uno board can be powered by the USB (5 Volts nominal, 4.5 Volts min.) or by an external supply from 6 to 14 Volts, thanks to a 5 Volts voltage regulator. The board also has a 3.3 Volts regulator for the needs of shields.

<p>Note: Around year 2000 the standard supply voltage for microcontrollers was shifted from 5 Volts to 3.3 Volts, this change was also applied to every digital chip communicating with SPI, I2C, UART.<br>
The ATmega328P could run from 3.3 Volts at a reduced clock frequency, but Arduino chose to stick to 5 Volts. For this reason, the accessory boards or "shields" frequently include voltage translator ICs to ensure compatibility with 3.3V chips.</p>

<div class="nob">
<h3>5.3.2 The Arduino software</h3>

<p>Arduino proposes an IDE (Integrated Development Environment) running on a host computer (Windows, Mac OS, Linux).<br>
This IDE is free and open-source, being based on existing open-source projects, mainly the <a href="https://github.com/WiringProject/Wiring">wiring IDE</a> and the <a href="https://gcc.gnu.org/">GCC compiler</a>, which is a C/C++ toolchain.<br>
The IDE contains the following software components :</p>
<ul><li>A simple text editor with syntax highlighting</li>
<li>A build system which is aware of the Arduino libraries and performs some text pre-processing before calling the GCC compiler and linker</li>
<li>An uploader utility, which communicates with the target microcontroller's bootloader via the USB link and the USB to UART bridge</li>
<li>A serial monitor, which is a terminal allowing to exchange text messages with a user program running on the target microcontroller</li>
<li>A serial plotter, which draws graphics from the data it receives from the target microcontroller</li>
</ul>
</div>

<div class="nob">
<p>With the intention of keeping things apparently simple, the IDE ('legacy version') comes with the following limitations:</p>
<ul><li>Splitting the source code into more than one file is not encouraged</li>
<li>Browsing the source code over multiple files is not supported, but a context sensitive help is available for Arduino library functions</li>
<li>Build steps are hidden, unless switched to "verbose" in the preferences</li>
<li>No incremental build</li>
<li>No debugger</li>
</ul>
</div>

<p>However, the system is more open that it seems at first sight. With some efforts it is possible to split the source code, use legacy C text formatting (snprintf), perform direct access to the peripheral registers, and use interrupts (all this thanks to the <a href="https://www.nongnu.org/avr-libc/user-manual/modules.html">avr-libc</a> library)</p>

<p>The C/C++ standards require a main() function with 2 optional arguments, returning an int.<br>
This is not adapted to the microcontroller, where the program cannot receive any argument and must never return.<br>
For this reason, the Arduino IDE expects the main program file to contain instead a setup() function and a loop() function.<br>
The setup() function is called once, then the loop() function call is repeated indefinitely.<br>
(These calls are included in a main() function created automatically by the Arduino build system).</p>

<p>Arduino jargon:</p>
<table class="bw">
<tr><td><i>Arduino term</i></td><td><i>actual meaning</i></td></tr>
<tr><td>Arduino language</td><td>C++, with specific libraries</td></tr>
<tr><td>sketch</td><td>a project for Arduino, in fact a directory containing<br>a single .ino source file and some documentation</td></tr>
<tr><td>sketchbook location</td><td>library search path root</td></tr>
<tr><td>file extension .ino</td><td>file extension .cpp</td></tr>
<tr><td>Verify</td><td>compile and link</td></tr>
<tr><td>Upload</td><td>compile and link then upload</td></tr>
<tr><td>analogRead()</td><td>start an ADC conversion, wait for completion, return value</td></tr>
<tr><td>analogWrite()</td><td>first time, start a timer as PWM generator on that pin,<br>else update pulse width</td></tr>
<tr><td>attachInterrupt()</td><td>configure an external interrupt linked to one pin</td></tr>
</table>
 
<h3>5.3.3 The microcontroller as a PC peripheral</h3>
<p>The USB to UART bridge which is on the Uno board is viewed by the host computer as a CDC (Communication Device Class) USB device.<br>
This means that, beside the two possibilities offered by the Arduino IDE, any program running on the host computer may dialog with the target microcontroller, using the standard serial communication interface of the computer (the COM ports in Windows, the TTYs on Linux).</p> 

<p>The Arduino IDE has two built-in tools for serial communication :</p>
<ul><li>the Serial Monitor, a text-only terminal</li>
<li>the Serial Plotter, displaying curves according to numbers received from the microcontroller</li>
</ul>
<p>To send a text command to the board, use the input area at the top of the serial monitor or at the bottom of the serial plotter. A single byte command may be sent, by choosing "No line ending" instead of "Newline".</p>

<p>The serial plotter has some interesting undocumented properties, here are some tips:<br>
<ul><li>to plot N curves :
<ul><li>send an initial text line with N words (each one beginning with a letter, not a digit), to be displayed as labels for the curves</li>
<li>then send text lines, each one containing N numbers (separated by spaces or commas),<br>
each line will append a new segment to each of the N curves, and increments X by one unit</li>
</ul></li>
<li>horizontal scale : the X unit is always 1/500th of the window width, the first 500 text lines fill the window, then the curves are scrolled to the left</li>
<li>vertical scale : is automatically adjusted,<br>
to keep it stable, plot two additional curves with constant Ymin and Ymax values, then they will "frame" the graphics</li>
<li>to plot variables in real time, send lines periodically with a constant period, (delay function, or better, timer interrupt)</li>
<li>to plot calculated curves, or previously acquired measurements, send exactly 500 text lines, then pause to freeze the graphics</li>
</ul> 
<p>Notes:</p>
<ul><li>The serial monitor and the serial plotter cannot be active simultaeously</li>
<li>Each time the serial monitor or the serial plotter is started, the target microcontroller is reset.</li>
</ul>

<h3>5.3.4 Low level programming</h3>
<p>"Low level" means "close to the hardware", in a layered model of application development.<br>
The complications of this level are "abstracted" (hidden) by an intermediate layer of apparently simple functions ("drivers"), but it is sometimes necessary to be aware of the hidden details. The first step is to get familiar with the target microcontroller <a href="https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/ATmega48A-PA-88A-PA-168A-PA-328-P-DS-DS40002061B.pdf">reference manual</a></p>

<div class="nob">
<h4>GPIO direct access</h4>
<p>Pin direction may be configured using the <a href="https://www.arduino.cc/reference/en/language/functions/digital-io/pinmode/">pinMode() function</a>, writing and reading can be done one pin at a time with digitalWrite() and digitalRead()</p>
<p>By talking directly to the GPIO peripheral, it is possible to manipulate several pins simultaneously (up to 8).</p>
<p>For this it is worth noting that the I/O pins are grouped in GPIO ports, each one containing 8 pins.<br>In the case of the Uno board, three ports PB, PC and PD are used,
the correspondance between the GPIO port numbering and the Arduino pin numbering is documented on the <a href="Arduino_UNO-TH_Rev3e_schematic.pdf">Arduino UNO schematic</a> and the pinout diagram above.</p>
<p>Each port exposes three 8-bit registers, DDRx (the direction register), PORTx (the output register), PINx (the input register), x being B, C or D</p>
<p>In order to facilitate the access to these registers from a C/C++ program, symbols for every peripheral register are defined in file iom328p.h which is included by io.h which is included by Arduino.h which is included automatically in every Arduino "sketch".</p>
</div>

<h4>Timer interrupt and time measurement</h4>
<p>Function <a href="https://www.arduino.cc/reference/en/language/functions/time/millis/">millis()</a> provides a value of the duration elapsed since the last CPU reset, in ms. (It overflows approximately every 50 days).</p>
<p>On the Uno, Timer 0 is configured for providing this service. With a prescaled clock of 16000000/64 = 250000 Hz, its internal counter measures time with a 4 us resolution, and with its 8-bit capacity it overflows every 1.024 ms.<br>
In order to keep time on a longer scale, an overflow interrupt is configured to count the overflow events, and compute time in milliseconds from the overflows count and the timer internal counter.</p>
<p>Function delay() just sets an arrival date (millis() + duration) and loops waiting for reaching this date.<br>In multitasking applications, such a waiting loop is merged in the main loop in order to perform other tasks while waiting.</p>
<p>In the other hand, function delayMicroseconds() is based on an estimate of the execution duration of a repeated instructions sequence, it is worth using only for short durations (less than 1 ms).</p>
<p>Find file writing.c in the Arduino installation directory for all details</p>

<div class="nob">
<h4>PWM outputs</h4>
<p>The analogWrite() function starts a PWM source on one of the 6 PWM-capable pins, which is bound to one of the three timers of the Uno.<br>
This function allows to vary the duty cycle from 0 to 100% according to an 8-bit argument (0 to 255), but does not allow any control over the frequency.
<table class="bw">
<tr><td></td><td>digital pin</td><td>period</td></tr>
<tr><td>timer 0</td><td>5</td><td>1024 us</td></tr>
<tr><td>timer 0</td><td>6</td><td>1024 us</td></tr>
<tr><td>timer 1</td><td>9</td><td>2040 us</td></tr>
<tr><td>timer 1</td><td>10</td><td>2040 us</td></tr>
<tr><td>timer 2</td><td>3</td><td>2040 us</td></tr>
<tr><td>timer 2</td><td>11</td><td>2040 us</td></tr>
</table>
<p>Note: timer 0 is used for two purposes, which are compatible.</p>
<p>More details in document <a href="https://docs.arduino.cc/tutorials/generic/secrets-of-arduino-pwm">Secrets of Arduino PWM</a></p>
</div>

<div class="nob">
<h3>Document links :</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Microcontroller">en.wikipedia.org/wiki/Microcontroller</a></li>
<li><a href="jlcl14cwTOC.pdf">C language for beginners</a></li>
<li><a href="jlcpp12c.pdf">C++ language for beginners</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pulse-width_modulation">en.wikipedia.org/wiki/Pulse-width_modulation</a></li>
<li><a href="https://docs.arduino.cc/tutorials/generic/secrets-of-arduino-pwm">docs.arduino.cc/tutorials/generic/secrets-of-arduino-pwm</a></li>
<li><a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">en.wikipedia.org/wiki/Serial_Peripheral_Interface</a></li>
<li><a href="https://en.wikipedia.org/wiki/I%C2%B2C">en.wikipedia.org/wiki/I²C</a></li>
<li><a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter</a></li>
<li><a href="https://en.wikipedia.org/wiki/UTF-8">en.wikipedia.org/wiki/UTF-8</a></li>
<li><a href="https://en.wikipedia.org/wiki/Binary_number">en.wikipedia.org/wiki/Binary_number</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hexadecimal">en.wikipedia.org/wiki/Hexadecimal</a></li>
<li><a href="https://en.wikipedia.org/wiki/Two%27s_complement">en.wikipedia.org/wiki/Two%27s_complement</a></li>
<li><a href="Arduino_UNO-TH_Rev3e_schematic.pdf">Arduino UNO schematic</a></li>
<li><a href="https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ProductDocuments/DataSheets/ATmega48A-PA-88A-PA-168A-PA-328-P-DS-DS40002061B.pdf">ATmega328</a></li>
<li><a href="https://www.nongnu.org/avr-libc/user-manual/modules.html">www.nongnu.org/avr-libc/user-manual/modules.html</a></li>
</ul>
</div>

 
</div>
</body>
</html>